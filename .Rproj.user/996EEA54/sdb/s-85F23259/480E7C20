{
    "collab_server" : "",
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n#\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(plyr)\nshinyServer(function(input, output) {\n  \n  \n  fun1 <- reactive({\n    texto <- paste(\"aux <- \", input$expresion1)\n    eval(parse(text=texto))\n    aux\n  })\n  \n  fun2 <- reactive({\n    switch(input$expresion2,\n           \"unif\"= function(x) 1*(x>0 && x<1),\n           \"exp\"= function(x) dexp(x)*(x>0),\n           \"norm\" = function(x) dnorm(x)\n    )\n  })\n  \n  output$Grafica <- renderPlot({\n    x <- seq(input$xmin, input$xmax, length.out=100)\n    y1 <- sapply(x, fun1())\n    y2 <- input$M*sapply(x, fun2())\n    plot_limit = c(min(c(y1, y2)), max(c(y1, y2)))\n    # tarea: investigar sapply, lapply, apply, tapply, mapply\n    plot(x, y1, type=\"l\", col=\"blue\", main=\"GrÃ¡fica\", ylim=plot_limit)\n    lines(x, y2, col=\"red\")\n    legend(\"topright\", c(\"f\", \"M*g\"), col=c(\"blue\", \"red\"), lty = 1)\n  })\n  # \n  \n  simulaciones <- reactive({\n    num_aceptados <- 0\n    num_intentos <- 0\n    sim_Y <- switch(input$expresion2,\n                    \"unif\"= function() runif(1),\n                    \"exp\"= function() rexp(1),\n                    \"norm\" = function() rnorm(1)\n    )\n    # print(sim_Y)\n    valor_aceptados <- numeric(input$nsim)\n    while(num_aceptados < input$nsim){\n      Y <- sim_Y()\n      U <- runif(1)\n      if(Y >= input$xmin && Y<=input$xmax && U <= (fun1()(Y))/(input$M*(fun2()(Y)))){\n        num_aceptados <- num_aceptados + 1\n        valor_aceptados[num_aceptados] <- Y\n      }\n      num_intentos <- num_intentos + 1\n    }\n    # print(valor_aceptados)\n    list(valor=valor_aceptados, tasa_exito=input$nsim/num_intentos)\n  })\n  \n  output$tasa_exito <- renderText({\n    simulaciones()$tasa_exito\n  })\n  \n  output$hist_sim <- renderPlot({\n    hist(simulaciones()$valor, main=\"Histograma de las simulaciones\", breaks=input$nbins)\n  })\n  \n  #------------------------------------------------------------------------\n  #                  FUNCION INVERSA\n  #------------------------------------------------------------------------\n  \n\n  \n  rExp <- function(nsim, lambda){\n    \n    return((-1/lambda)*log(1-runif(nsim)))\n    \n  }\n  \n  simular <- reactive({\n    seed <- set.seed(134934)\n    numsim <- input$nsim\n    lambd <- input$lambda\n    rExp(numsim,lambd)\n  })\n  \n  reactive_lambda <- reactive({\n    input$lambda\n  })\n  \n  \n  output$simulated <- renderPlot({\n  \n  dat <- data.frame(Value=rExp(input$nsim, input$lambda))\n  \n  ggplot(dat, aes(x=Value)) +\n    \n    geom_histogram(aes(y=..density..), binwidth= .2, colour=\"black\", fill=\"white\") +\n    \n    stat_function(fun = function(x) input$lambda*exp(-input$lambda*x),colour = \"blue\")\n  \n})\n  #------------------------------------------------------------------------\n  #                  Integracion por Monte Carlo \n  #------------------------------------------------------------------------\n  \n  funcii <- reactive({\n    texto <- paste(\"aux <- \", input$funci)\n    eval(parse(text=texto))\n    aux\n  })\n  \n  \n  mc.intervals <- function(Phi, N, X.dens=runif, alpha=al){\n    \n    results.list <- lapply(N, function(nsim2){\n      \n      X <- sapply(FUN=X.dens, nsim2) # N samples of the density of X\n      PhiX <- sapply(X, Phi) # Evaluate phi at each X_i\n      estim <- mean(PhiX) # Estimate of int_a^b \\phi(x)f(x)df=E[phi(X_i)]\n      S2 <- var(PhiX) # Estimate of the variance of phi(X_i)\n      quant <- qnorm(alpha/2, lower.tail=FALSE) # Right quantile for alpha/2\n      int.upper <- estim + sqrt(S2/nsim2)*quant # Upper confidence interval\n      int.lower <- estim - sqrt(S2/nsim2)*quant # Lower confidence interval\n      return(data.frame(N=nsim2, Estimate=estim, LI=int.lower, UI=int.upper))\n      # -------\n    })\n    #\n    results.table <- ldply(results.list) # Assembles list in data.frame\n    return(results.table)\n  }\n  \n\n  \n  output$Grafica22<-renderPlot({\n   \n  nsim2<-input$nsim2\n  al<-input$alpha\n  set.seed(134934)\n  Phi <- funcii()\n  X.dens <- function(nsim2) runif(nsim2, input$a, input$b)\n  N <- seq(from=input$nmin, to=input$nmax, by=100)\n  data <- mc.intervals(Phi=Phi, N=N, X.dens=X.dens,al)\n  data\n  \n  g1<-ggplot(data, aes(x=N)) +\n    geom_ribbon(aes(ymin=LI, ymax=UI), fill=\"grey\", alpha=0.4) +\n    geom_line(aes(y=Estimate), colour=\"blue\") \n  \n  g1\n  \n  })\n  \n  #------------------------------------------------------------------------\n  #                  Metropolis-Hastings\n  #------------------------------------------------------------------------\n  \n  output$table <- DT::renderDataTable(DT::datatable({\n    data <- p14\n    data\n  }))\n  \noutput$g1<- renderPlot({\n  ns<- input$ns\n  y<-input$y\n  x<-input$x\n  p13<-cbind(y,x)\n  eps <- function(ns) runif(input$ns, input$y, input$x)\n  pairs(y~x,data=p13, \n        main=\"Diagrama de dispersion\")\n})\n   \n  \n\n})",
    "created" : 1481562914404.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1464910928",
    "id" : "480E7C20",
    "lastKnownWriteTime" : 1481676086,
    "last_content_update" : 1481676086507,
    "path" : "~/CompStat2016/Jimena/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}