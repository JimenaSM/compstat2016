{
    "collab_server" : "",
    "contents" : "#Esta parte es el server en el cual se escriben las instrucciones \n#lógicas de la tarea de el curso de estadística computacional.\n\nlibrary(shiny)\nlibrary(ggplot2)\n\nshinyServer(function(input, output) {\n  ##### PARTE DEL SERVER PARA INTEGRACIÓN MONTECARLO ###############################\n  \n  g <- reactive({\n    texto <- paste(\"aux <- \", input$funcion)\n    eval(parse(text=texto))\n    aux\n  })\n  \n  auoutput$distPlot <- renderPlot({\n    \n    #Mandamos llamar los input disponibles en el ui para montecarlo\n    \n    n_sim <- input$n_sim\n    n_min = input$n_min\n    n_max = input$n_max\n    alpha = input$alpha\n    a = input$a\n    b = input$b\n    \n    \n    result = replicate(n_sim, {\n      n = floor(runif(1 ,n_min, n_max))\n      x = runif(n, min=a, max=b)\n      g_x = sapply(x , g())\n      est = mean(g_x)\n      CI = est + c(-1,1)*qnorm(1-alpha/2)*sqrt(var(g_x)/n)\n      (c(n,est,CI[1],CI[2]))\n    })\n    \n    result = as.data.frame(t(result))\n    names(result) = c(\"Simulaciones\",\"Estimacion\",\"IC_Inferior\",\"IC_Superior\")\n    \n    g2 = ggplot(result, aes(x=Simulaciones,y=Estimacion)) + \n      ggtitle(paste(\"Estimación Montecarlo con Intervalos de confianza al \",(1-alpha)*100)) +\n      geom_line(aes(y = Estimacion), colour = \"red\") +\n      geom_ribbon(aes(ymin = IC_Inferior, ymax = IC_Superior), alpha = 0.4)\n    \n    g2\n    \n    \n    \n  })  \n  \n  \n  ##### PARTE DEL SERVER PARA LA PARADOJA DEL CUMPLEAÑOS ###############################\n  bdayPrx <- function(n_sim, n_personas) {\n    replicate(n_sim, {\n      bdays <- sample.int(365, n_personas, replace=TRUE)\n      exito <- (anyDuplicated(bdays)>0)\n      exito\n    })\n  }\n  prob_exito <- function(bdayPrx){\n    mean(bdayPrx)\n  } \n  \n  personas_necesarias <- function(n_sim, n_personas) {\n    replicate(n_sim, {\n      i <- 1\n      bdays <- sample.int(365, 1)\n      while(anyDuplicated(bdays)==0){\n        bdays <- c(bdays, sample.int(365, 1))\n        i <- i + 1\n      }\n      i\n    })\n  }\n  \n  PersonasNec <- function(personas_necesarias){\n    mean(personas_necesarias)\n  } \n  \n  #Wraps a normal expression to create a reactive expression. Conceptually, \n  # a reactive expression is a expression whose result will change over time\n  \n  n_simulaciones <- reactive({\n    seed <- set.seed(127049)\n    numero_simulaciones <- input$n_sim\n    numero_personas <- input$n_personas\n    bdayPrx(lambda, runif(number_simulations))\n  })\n  # \n  # #Para variar lambda cuando se actualice\n  # reactive_lambda <- reactive({\n  #   input$lambda\n  # })\n  \n  \n  \n  # output$simulated <- renderPlot({\n  #   x <- simulated()\n  #   hist(x, breaks = 20)\n  # })\n  # \n  # output$expected <- renderPlot({\n  #   input$lambda\n  #   lambda <- reactive_lambda()\n  #   Z <- simulated()\n  #   p <- ppoints(input$simulaciones)    # 100 equally spaced points on (0,1), excluding endpoints\n  #   q <- quantile(Z, p=p) # percentiles of the sample distribution\n  #   plot(qexp(p) , q, main=\"Exponential Q-Q Plot\", xlab=\"Theoretical Quantiles\", ylab=\"Sample Quantiles\")\n  # })\n  \n  \n  \n  \n  ##### PARTE DEL SERVER PARA LA FUNCION INVERSA ###############################\n  expInv <- function(lambda, U) {\n    -log(1 - U)/lambda \n  }\n  \n  simulated <- reactive({\n    seed <- set.seed(127049)\n    number_simulations <- input$simulaciones\n    lambda <- input$lambda\n    expInv(lambda, runif(number_simulations))\n  })\n  \n  #Para variar lambda cuando se actualice\n  reactive_lambda <- reactive({\n    input$lambda\n  })\n  \n  output$simulated <- renderPlot({\n    x <- simulated()\n    hist(x, breaks = 20)\n  })\n  \n  output$expected <- renderPlot({\n    input$lambda\n    lambda <- reactive_lambda()\n    Z <- simulated()\n    p <- ppoints(input$simulaciones)    # 100 equally spaced points on (0,1), excluding endpoints\n    q <- quantile(Z, p=p) # percentiles of the sample distribution\n    plot(qexp(p) , q, main=\"Exponential Q-Q Plot\", xlab=\"Theoretical Quantiles\", ylab=\"Sample Quantiles\")\n  })\n  \n  \n  ##### PARTE DEL SERVER PARA ACEPTACIÓN RECHAZO ###############################  \n  fun1 <- reactive({\n    texto <- paste(\"aux <- \", input$expresion1)\n    eval(parse(text=texto)) \n    aux\n  })\n  \n  fun2 <- reactive({\n    switch(input$expresion2,\n           \"unif\"= function(x) 1*(x>0 && x<1),\n           \"exp\"= function(x) dexp(x)*(x>0),\n           \"norm\" = function(x) dnorm(x)\n    )\n  })\n  \n  output$Grafica <- renderPlot({\n    x <- seq(input$xmin, input$xmax, length.out=100)\n    y1 <- sapply(x, fun1())\n    y2 <- input$M*sapply(x, fun2())\n    plot_limit = c(min(c(y1, y2)), max(c(y1, y2)))\n    # tarea: investigar sapply, lapply, apply, tapply, mapply\n    plot(x, y1, type=\"l\", col=\"blue\", main=\"Gráfica\", ylim=plot_limit)\n    lines(x, y2, col=\"red\")\n    legend(\"topright\", c(\"f\", \"M*g\"), col=c(\"blue\", \"red\"), lty = 1)\n  })\n  # \n  \n  simulaciones <- reactive({\n    num_aceptados <- 0\n    num_intentos <- 0\n    sim_Y <- switch(input$expresion2,\n                    \"unif\"= function() runif(1),\n                    \"exp\"= function() rexp(1),\n                    \"norm\" = function() rnorm(1)\n    )\n    # print(sim_Y)\n    valor_aceptados <- numeric(input$nsim)\n    while(num_aceptados < input$nsim){\n      Y <- sim_Y()\n      U <- runif(1)\n      if(Y >= input$xmin && Y<=input$xmax && U <= (fun1()(Y))/(input$M*(fun2()(Y)))){\n        num_aceptados <- num_aceptados + 1\n        valor_aceptados[num_aceptados] <- Y\n      }\n      num_intentos <- num_intentos + 1\n    }\n    # print(valor_aceptados)\n    list(valor=valor_aceptados, tasa_exito=input$nsim/num_intentos)\n  })\n  \n  output$tasa_exito <- renderText({\n    simulaciones()$tasa_exito\n  })\n  \n  output$hist_sim <- renderPlot({\n    hist(simulaciones()$valor, main=\"Histograma de las simulaciones\", breaks=input$nbins)\n  })\n  \n  \n})",
    "created" : 1481562939276.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "2847429397",
    "id" : "E3E7EE93",
    "lastKnownWriteTime" : 234456848,
    "last_content_update" : 1481587609068,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}